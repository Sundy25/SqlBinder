using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text.RegularExpressions;
using SqlBinder.ConditionValues;
using SqlBinder.Parsing;
using SqlBinder.Properties;

namespace SqlBinder
{
	/// <summary>
	/// Provides capability to parse and execute an SqlBinder script and set conditions to be matched against it.
	/// </summary>
	public class Query
	{
		internal Query(SqlBinder sq)
		{
			SqlBinder = sq;
		}

		internal Query(SqlBinder sq, string script)
		{
			SqlBinder = sq;
			SqlBinderScript = script;
		}

		/// <summary>
		/// Gets the parent SqlBinder class.
		/// </summary>
		public SqlBinder SqlBinder { get; internal set; }

		/// <summary>
		/// Gets or sets an SqlBinder script that was passed to this query.
		/// </summary>
		public string SqlBinderScript { get; set; }

		/// <summary>
		/// Gets the conditions which are required in order to build a valid query. There can be one condition for each query parameter.
		/// </summary>
		public List<Condition> Conditions { get; internal set; } = new List<Condition>();

		/// <summary>
		/// Gets or sets a collection of query-scoped variables that will be passed onto the parser engine.
		/// </summary>
		public Dictionary<string, object> Variables { get; set; } = new Dictionary<string, object>();

		/// <summary>
		/// Gets a list of errors that were generated by the parser engine after calling CreateCommand method.
		/// </summary>
		public string ParserErrors { get; private set; }

		/// <summary>
		/// Gets a list of warnings that were generated by the parser engine after calling CreateCommand method.
		/// </summary>
		public string ParserWarnings { get; private set; }

		/// <summary>
		/// Gets a <see cref="IDbCommand"/> associated with this query.
		/// </summary>
		public IDbCommand DbCommand { get; private set; } 
		
		/// <summary>
		/// Creates a condition for the query.
		/// </summary>
		/// <param name="parameterName">Name of the parameter for which this condition applies.</param>
		/// <param name="op">Condition operator.</param>
		/// <param name="value">Value of the condition. You can use your own or already predefined classes 
		/// such as <see cref="DateValue"/>, <see cref="NumberValue"/>, <see cref="StringValue"/> or <see cref="BoolValue"/>.</param>
		public virtual void SetCondition(string parameterName, Operator op, ConditionValue value)
		{
			if (parameterName == null)
				throw new ArgumentException(nameof(parameterName));

			RemoveCondition(parameterName);
			Conditions.Add(new Condition(parameterName, op, value));
		}

		/// <summary>
		/// Creates a <see cref="Condition"/> for the query.
		/// </summary>
		/// <param name="parameterName">Name of the query parameter for which this condition applies.</param>
		/// <param name="value">Value of the condition. You can use your own or already predefined classes
		/// such as <see cref="DateValue"/>, <see cref="NumberValue"/>, <see cref="StringValue"/> or <see cref="BoolValue"/>.</param>
		public virtual void SetCondition(string parameterName, ConditionValue value)
		{
			SetCondition(parameterName, Operator.Is, value);
		}

		/// <summary>
		/// Translates a number-specific NumericOperator enum into a general purpose Operator enum.
		/// </summary>
		protected static Operator TranslateOperator(NumericOperator conditionOperator)
		{
			switch (conditionOperator)
			{
				case NumericOperator.IsNot: return Operator.IsNot;
				case NumericOperator.IsGreaterThan: return Operator.IsGreaterThan;
				case NumericOperator.IsGreaterThanOrEqualTo: return Operator.IsGreaterThanOrEqualTo;
				case NumericOperator.IsLessThan: return Operator.IsLessThan;
				case NumericOperator.IsLessThanOrEqualTo: return Operator.IsLessThanOrEqualTo;
				default: return Operator.Is;
			}
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="NumberValue"/> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, decimal? from = null, decimal? to = null, bool inclusive = false)
		{
			var grthan = inclusive ? Operator.IsGreaterThanOrEqualTo : Operator.IsGreaterThan;
			var lessthan = inclusive ? Operator.IsLessThanOrEqualTo : Operator.IsLessThan;

			if (from.HasValue && to.HasValue)
				SetCondition(parameterName, Operator.IsBetween, new NumberValue(from.Value, to.Value));
			else if (from.HasValue)
				SetCondition(parameterName, grthan, new NumberValue(from.Value));
			else if (to.HasValue)
				SetCondition(parameterName, lessthan, new NumberValue(to.Value));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="NumberValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, decimal value, NumericOperator conditionOperator = NumericOperator.Is)
		{
			SetCondition(parameterName, TranslateOperator(conditionOperator), new NumberValue(value));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="NumberValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, IEnumerable<decimal> values, bool isNot = false)
		{
			SetCondition(parameterName, isNot ? Operator.IsNotAnyOf : Operator.IsAnyOf, new NumberValue(values));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="NumberValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, int value, NumericOperator conditionOperator = NumericOperator.Is)
		{
			SetCondition(parameterName, TranslateOperator(conditionOperator), new NumberValue(value));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="NumberValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, IEnumerable<int> values, bool isNot = false)
		{
			SetCondition(parameterName, isNot ? Operator.IsNotAnyOf : Operator.IsAnyOf, new NumberValue(values));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="NumberValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, long value, NumericOperator conditionOperator = NumericOperator.Is)
		{
			SetCondition(parameterName, TranslateOperator(conditionOperator), new NumberValue(value));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="NumberValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, IEnumerable<long> values, bool isNot = false)
		{
			SetCondition(parameterName, isNot ? Operator.IsNotAnyOf : Operator.IsAnyOf, new NumberValue(values));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="DateValue"/> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, DateTime? from = null, DateTime? to = null, bool inclusive = true)
		{
			var grthan = inclusive ? Operator.IsGreaterThanOrEqualTo : Operator.IsGreaterThan;
			var lessthan = inclusive ? Operator.IsLessThanOrEqualTo : Operator.IsLessThan;

			if (from.HasValue && to.HasValue)
				SetCondition(parameterName, Operator.IsBetween, new DateValue(from.Value, to.Value));
			else if (from.HasValue)
				SetCondition(parameterName, grthan, new DateValue(from.Value));
			else if (to.HasValue)
				SetCondition(parameterName, lessthan, new DateValue(to.Value));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="DateValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, DateTime? value, NumericOperator conditionOperator = NumericOperator.Is)
		{
			SetCondition(parameterName, TranslateOperator(conditionOperator), new DateValue(value));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="DateValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, IEnumerable<DateTime> values, bool isNot = false)
		{
			SetCondition(parameterName, isNot ? Operator.IsNotAnyOf : Operator.IsAnyOf, new DateValue(values));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="DateValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, bool value)
		{
			SetCondition(parameterName, Operator.Is, new BoolValue(value));
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="StringValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, string value, StringOperator conditionOperator = StringOperator.Is)
		{
			SetCondition(parameterName, TranslateStringOperator(conditionOperator), new StringValue(value));
		}

		/// <summary>
		/// Translates the string-specific StringOperator enum into a general purpose Operator enum.
		/// </summary>
		protected static Operator TranslateStringOperator(StringOperator conditionOperator)
		{
			switch (conditionOperator)
			{
				case StringOperator.IsLike: return Operator.Contains;
				case StringOperator.IsNotLike: return Operator.DoesNotContain;
				case StringOperator.IsNot: return Operator.IsNot;
				default: return Operator.Is;
			}
		}

		/// <summary>
		/// Creates a <see cref="Condition" /> with <see cref="StringValue" /> for the query.
		/// </summary>
		public virtual void SetCondition(string parameterName, IEnumerable<string> values, bool isNot = false)
		{
			SetCondition(parameterName, isNot ? Operator.IsNotAnyOf : Operator.IsAnyOf, new StringValue(values));
		}

		/// <summary>
		/// Returns a condition by its associated query parameter or null if not found.
		/// </summary>
		public virtual Condition GetCondition(string parameterName) => Conditions.FirstOrDefault(c => c.Parameter == parameterName);

		/// <summary>
		/// Removes a condition (if any) by its associated query parameter.
		/// </summary>
		public virtual void RemoveCondition(string parameterName) => Conditions.Remove(GetCondition(parameterName));

		/// <summary>
		/// Defines a user variable that can be used when this query is executed by the template parser engine.
		/// </summary>
		/// <param name="name">The name of the variable.</param>
		/// <param name="value">The value.</param>
		public virtual void DefineVariable(string name, object value) => Variables[name] = value;

		private readonly HashSet<Condition> _processedConditions = new HashSet<Condition>();

		/// <summary>
		/// Processes the script and creates a <see cref="IDbCommand"/> command.
		/// </summary>			
		public virtual IDbCommand CreateCommand()
		{
			var parser = new Parser();

			parser.RequestParameterValue += parser_RequestParameterValue;

			DbCommand = SqlBinder.DataConnection.CreateCommand();
			DbCommand.CommandType = CommandType.Text;

			ParserBuffer pr;

			try
			{
				pr = parser.Parse(SqlBinderScript);
			}
			catch (Exception ex)
			{
				throw new ParserException(ex);
			}

			if (!pr.IsValid)
			{
				ParserErrors = pr.Errors;
				if (SqlBinder.ThrowScriptErrorException && pr.CompileException != null)
					throw new ParserException(pr.CompileException);
			}

			var unprocessedConditions = Conditions.Except(_processedConditions).ToArray();
			if (unprocessedConditions.Any())
				throw new UnmatchedConditionsException(unprocessedConditions);

			ParserWarnings = pr.Warnings;

			DbCommand.CommandText = pr.Output;

			return DbCommand;
		}		

		private void parser_RequestParameterValue(object sender, RequestParameterArgs e)
		{
			var cond = Conditions.FirstOrDefault(c => string.CompareOrdinal(c.Parameter, e.Parameter.Name) == 0);
			
			if (cond != null)
			{
				_processedConditions.Add(cond);

				if (e.Parameter.IsCompound)
					e.Values = cond.Value.GetValues().Select(v => (object)$"'{v}'").ToArray();
				else
				{
					var sql = ConstructParameterSql(cond.Operator, cond.Value, cond.Parameter);
					e.Values = new object[] { sql };
				}

				e.Processed = true;
			}
			else
			{
				var variableName = e.Parameter.Name + e.Parameter.Member;
				object variableValue = null;

				if (Variables.ContainsKey(variableName))
					variableValue = Variables[variableName];
				else if (SqlBinder.Variables.ContainsKey(variableName))
					variableValue = SqlBinder.Variables[variableName];

				if (variableValue != null)
				{
					if (variableValue.GetType().IsArray)
						e.Values = (object[])variableValue;
					else
						e.Values = new[] { variableValue };

					e.Processed = true;
				}
			}
		}

		/// <summary>
		/// Compiles a command parameter sql based on query parameter, operator and value.
		/// </summary>
		protected virtual string ConstructParameterSql(Operator sqlOperator, ConditionValue conditionValue, string parameter)
		{
			try
			{
				var sql = conditionValue.GetSql(sqlOperator);

				if (string.IsNullOrEmpty(sql))
					throw new InvalidOperationException(Exceptions.EmptySqlReturned);

				var values = conditionValue.GetValues();

				if (values == null || values.Length <= 0)
					return sql;

				var paramsSql = new object[values.Length];
				var paramCnt = 1;

				// Create command paramete(s) for each value
				for (var i = 0; i < values.Length; i++)
				{
					var value = values[i];

					if (!(value is string) && value is IEnumerable valueEnumerable)
					{
						if (conditionValue.UseBindVariables)
						{
							// This value is enumerable (e.g. IN, NOT IN)
							var sqlParamNames = new List<string>();
							foreach (var subValue in valueEnumerable)
							{
								var paramName = $"p{parameter}_{paramCnt}";
								var param = AddCommandParameter(paramName, subValue);
								conditionValue.ProcessParameter(param);
								sqlParamNames.Add(SqlBinder.FormatParameterNameInternal(this, paramName));
								paramCnt++;
							}

							paramsSql[i] = string.Join(", ", sqlParamNames.ToArray());
						}
						else
							paramsSql[i] = string.Join(", ", valueEnumerable);
					}
					else
					{
						if (conditionValue.UseBindVariables)
						{
							var paramName = $"p{parameter}_{paramCnt}";
							var param = AddCommandParameter(paramName, value);
							conditionValue.ProcessParameter(param);
							paramsSql[i] = SqlBinder.FormatParameterNameInternal(this, paramName);
						}
						else
							paramsSql[i] = value;
					}

					paramCnt++;
				}

				sql = string.Format(sql, paramsSql);

				return sql;
			}
			catch (Exception ex)
			{
				throw new InvalidConditionException(conditionValue, sqlOperator, ex);
			}
		}

		/// <summary>
		/// When overriden in a derived class it allows customizing ADO DbType guessing based on clr types.
		/// </summary>
		protected virtual DbType OnResolveDbType(Type type) => SqlBinder.ResolveDbType(type);

		/// <summary>
		/// Delegate that can be used to intercept and alter command parameters on the fly. Use this to pass custom DBMS parameters. This is called
		/// before the parameter is added to command so you can either return the same reference or create your own.
		/// </summary>
		public Func<IDbDataParameter, IDbDataParameter> PrepareCmdParameter = p => p;

		/// <summary>
		/// Adds a parameter to the output command, parameter type will be resolved by the virtual OnResolveDbType method.
		/// </summary>
		protected virtual IDbDataParameter AddCommandParameter(string paramName, object paramValue)
		{
			var param = DbCommand.CreateParameter();

			param.Direction = ParameterDirection.Input;

			if (paramValue == null)
				param.DbType = DbType.Object;
			else
			{
				param.DbType = OnResolveDbType(paramValue.GetType());

				if (paramValue is char)
					param.Size = 1;
			}

			param.Value = paramValue ?? DBNull.Value;
			param.ParameterName = paramName;

			param = PrepareCmdParameter(param);

			DbCommand.Parameters.Add(param);

			return param;
		}
	}
}
